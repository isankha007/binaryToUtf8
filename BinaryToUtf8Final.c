//
//  main.c
//  BinaryToUTF
//
//  Created by Sankhadeep Chatterjee on 25/12/16.
//  Copyright Â© 2016 Sankhadeep Chatterjee. All rights reserved.
//

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <locale.h>
#define MAX 1000
char buf[255];

#define SIZE_OF_ARRAY(_array) (sizeof(_array) / sizeof(_array[0]))
void processBinaryData(char* pBinaryData,int32_t n,char *unicodeString);
int32_t returnInt32ValueUsing7bits(char *pBinaryData);
void splitByteStreamFor8ByteAndReturnUnicode(char *source,int32_t *pOffset,char *finalnew_str);

//http://stackoverflow.com/questions/23476598/c-windows-decimal-to-utf-8-character-conversion
//////////////////////////////////////////////////////////////////////////////////////////////////////
void GetUnicodeChar(unsigned int code, char chars[5]) {

    if (code <= 0x7F) {
        chars[0] = (code & 0x7F); chars[1] = '\0';
    } else if (code <= 0x7FF) {
        // one continuation byte
        chars[1] = 0x80 | (code & 0x3F); code = (code >> 6);
        chars[0] = 0xC0 | (code & 0x1F); chars[2] = '\0';
    } else if (code <= 0xFFFF) {
        // two continuation bytes
        chars[2] = 0x80 | (code & 0x3F); code = (code >> 6);
        chars[1] = 0x80 | (code & 0x3F); code = (code >> 6);
        chars[0] = 0xE0 | (code & 0xF); chars[3] = '\0';
    } else if (code <= 0x10FFFF) {
        // three continuation bytes
        chars[3] = 0x80 | (code & 0x3F); code = (code >> 6);
        chars[2] = 0x80 | (code & 0x3F); code = (code >> 6);
        chars[1] = 0x80 | (code & 0x3F); code = (code >> 6);
        chars[0] = 0xF0 | (code & 0x7); chars[4] = '\0';
    } else {
        // unicode replacement character
        chars[2] = 0xEF; chars[1] = 0xBF; chars[0] = 0xBD;
        chars[3] = '\0';
    }
  //  printf("YYYY %c %c %c %c \n", chars[0], chars[1], chars[2], chars[3]);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
char* int2utf8(int code) {
   if(code <= 0x7F) {
      sprintf(buf, "%c", (unsigned char)code);
      return buf;
   }
   if(code >= 0x80 && code <= 0x7FF) {
      sprintf(buf, "%c%c", 0xC0 | (code >> 6), 0x80 | (code & 0x3F));
      return buf;
   }
   if((code >= 0x800  && code <= 0xD7FF) ||
      (code >= 0xE000 && code <= 0xFFFF)) {
      sprintf(buf, "%c%c%c", 0xE0 | (code >> 12),0x80 | ((code >> 6) & 0x3F), 0x80 | (code & 0x3F));
      return buf;
   }
   if(code >= 0x10000 && code <= 0x10FFFF) {
      sprintf(buf, "%c%c%c%c", 0xF0 | (code >> 18), 0x80 | ((code >> 12) & 0x3F), 0x80 | ((code >> 6) & 0x3F), 0x80 | (code & 0x3F));
      return buf;
   }

   return 0;
}*/

int bin2dec(char* str) {
    int n = 0;

    int size = strlen(str) - 1;
    int count = 0;
    while ( *str != '\0' ) {
        if ( *str == '1' ){
            n = n + pow(2, size - count );
        }
        count++;
        str++;
    }

    //printf("Decimal Value %d",n);
    return n;
}

/*void binaryUTF8toDecimal(char *pBinaryData,char *unicodeString){
    int32_t lByteCount=0;//charCount=0;

    while(pBinaryData[lByteCount] != '0'){
        lByteCount++;

    }
    size_t len = strlen((char *)pBinaryData);
    //printf("SIZE of Array %d\n",len);
    if((lByteCount>1&&(len/8 == lByteCount))||lByteCount==0){
        //printf("valid UNICODE\n");

        processBinaryData(pBinaryData,lByteCount,&unicodeString);

    }


}*/


void processBinaryData(char* pBinaryData,int32_t n,char *unicodeString){
    char arr[n*8],i=1,offset=0;
    int m =0;
    if(n>1){
        size_t len = strlen((char *)pBinaryData);
        while(len>0){
            len = len-8;
            if(i==1){
                offset= n+1;
                memset(arr, 0, n*8);
                for( m=0;m<8-(n+1);m++){
                    arr[m] = pBinaryData[offset+m];
                }
                offset = 10;//offset+8-(n+1)+2;
            }else{
                int j = 0;
                for( j=0;j<6;j++){//i*8-2
                    arr[m] = pBinaryData[offset];
                    m++;
                    offset++;
                }
                offset=i*8+2;

            }
            i++;
        }
        GetUnicodeChar(bin2dec(arr),unicodeString);
        int2utf8(bin2dec(arr));
        //printf("%s\n", int2utf8(bin2dec(arr)));
///////////////////

    }
    else{

        GetUnicodeChar(bin2dec(pBinaryData),unicodeString);
        int2utf8(bin2dec(pBinaryData));
        //printf("%s\n", int2utf8(bin2dec(pBinaryData)));

        return;


    }





}

void extractUnicode(char *source,char *finalnew_str){

    char unicodeString[5] ;
    char result[100];
    int lByteCount=0;
    int32_t pOffset=0;
    while(pOffset<strlen(source)){
        if(source[pOffset]=='0'){
            lByteCount=1;
        }else{
            while(source[lByteCount+pOffset]!='0'){
                lByteCount++;
            }
        }



            memset(result, 0, lByteCount*8+1);
            memcpy(result, source+pOffset, lByteCount*8);

        pOffset=pOffset+lByteCount*8;



        if(sizeof(result)>0)
        	processBinaryData(result, lByteCount,unicodeString);
        // binaryUTF8toDecimal(result,unicodeString);
        lByteCount=0;
        //printf("\n%s",unicodeString);

        if(finalnew_str==NULL){
            memset(finalnew_str, 0, 1000);
            memcpy(finalnew_str, unicodeString, strlen(unicodeString));
        }else{
            strcat(finalnew_str,unicodeString);
        }

    }

    //printf("%s",finalnew_str);
}

int32_t returnInt32ValueUsing7bits(char *pBinaryData)
{
	int32_t i=0,lResult = 0, power=0;
	for(i=8; i>0; i--)
	{
		lResult = lResult + ((pBinaryData[ (i-1)]-48) * pow(2, power));
		power++;
		if((power%7)==0) i--;
	}
	return lResult;
}

void splitByteStreamFor8ByteAndReturnUnicode(char *source,int32_t *pOffset,char *finalnew_str){
	char result[9];

	//check for byte length

	 memset(result, 0, 9);
	 memcpy(result, source+*pOffset, 8);
     int32_t unicodeLength=returnInt32ValueUsing7bits(result)-1;
     *pOffset=*pOffset+8;
	 //printf("Split %d === Offset =%d \n", unicodeLength,*pOffset);
	 char finalstring[unicodeLength*8+1];
	 memset(finalstring, 0, unicodeLength*8+1);
	 memcpy(finalstring, source+*pOffset, unicodeLength*8);
	 memset(finalnew_str, 0, unicodeLength+1);
	 extractUnicode(finalstring,finalnew_str);
	 *pOffset += unicodeLength*8;
	// printf("Split unicode byte %s",finalnew_str);

}


int main(void) {

    char finalnew_str[MAX] ;
	char *source="0011101000000000000000000000000011000000100000111011101000100011011010000001000001110111010111010011010100101001101101010000000110111000010001110101101001010101101101111011000011010000101001001101000110001100110100011000111011010001100001111101000010110101110100011000000011010001100000011101000010111101110100011000101111010000101110010010000011010000101110101101000010111110110100001011110111010001100000101101000110000000110100001011000011010000101110101101000110000010001000000100011101000001010110100101001000101101001110010010111000110001001101110111011001010001011111001100011001000111010000010101101001010010001011010011100100101110001100011011011110111000100000000100011001011000010110000101100001011000110110001000000010000011100000011001001001010010010101011100001011000110100000100010100011000100100000001000010101000110010101010101010000101101010101000101001001000001010001000100010111010011100000001000000001000110010101010101010000101101010000100100111101001111010010110010110110110001100000101000001001000110010101010101010000101101010000100100111101001111010010110010110110110101100001101000001101000110010101010101010000101101010000100100111101001111010010110010110100110010101100001001010110000011010001100101010101010100001011010100001001001111010011110100101100101101001101011011000010110011100000111000001001000111010000010101101011010010100000001111101100000110000100000010110001011101101000001111101100000101001010010101000101100000111000001111101100000110000011011010000011111011000001100000110110100000111111100000110100010010111010001111111000001101000100101110100010000000100000001000000010000000100000001000000010000000100000001000001110000111000010010100111100010001101010010010001101101010001010110000010100101111001000110101000110000000100001010000100101001110010001001110001000100011011010000000110101101101000111110111101101000101100000000000100101001111000100011010101001100100000100010011000110000001";
			//"10100101000000000000000000000000110000001000001100000001101001010010001101101000000100000101110101000100010100000011100011111010000000011011011101010110010000100100110110110111101100001101000010100100110100011000110011010001100011101101000110000111110100001011010111010001100000001101000110000001110100001011110111010001100010111101000010111001001000001101000010111010110100001011111011010000101111011101000110000010110100011000000011010000101100001101000010111010110100011000001000100000010101100101010001000010010100100010110100110110001011100011000100110111011110000011101100101110110001100101011001010100010000100101001000101101001101100010111000110001101101111011100010000000010001100101100001011000010110000101100011011000100000001000011010000001100100100101001001010101110000101100011010000010001010001011111110000000100001010100011001010101010101000010110101010100010100100100000101000100010001011101001110000000100000000100011001010101010101000010110101000010010011110100111101001011001011011011000110000010100000100100011001010101010101000010110101000010010011110100111101001011001011011011010110000110100000110100011001010101010101000010110101000010010011110100111101001011001011010011001010110000100101011000001101000110010101010101010000101101010000100100111101001111010010110010110100110101101100001011001110000011100000100101011001010100010000101101001010000000111110110000001100001011011101010011111011100000111110110000001001010000000110110111000111100000111110110000011000001101101000001111101100000110000011011010000011111110000001110101001010010000111111100000011101010010100100001000000010000000100000001000000010000000100000001000000010000000100000111000011100001001010011110000111011110111001000110110101000100010000100010011011100001101011010011000000010000101000010010100111001000101101110000010001101101000000100000010110101001111011110100111110110000000000010010100111100001110111110000110010000010001001100011000000";
			//"101000110000000000000000000000001100000010000011000000011010001100100011011010000001000000101101000111010110110000110101111001110000000111001011010100100101001001001010101101111011000011010000101001001101000110001100110100011000111011010001100001111101000010110101110100011000000011010001100000011101000010111101110100011000101111010000101110010010000011010000101110101101000010111110110100001011110111010001100000101101000110000000110100001011000011010000101110101101000110000010001000000101001001010101010011110100111000101101001101000010111000110001001101110111010001001011000100001100011001010010010101010100111101001110001011010011010000101110001100011011011110111000100000000100011001011000010110000101100001011000110110001000000010000111100000011001001001010010010101011100001011000110100000100010100010110110100000001000010101000110010101010101010000101101010101000101001001000001010001000100010111010011100000001000000001000110010101010101010000101101010000100100111101001111010010110010110110110001100000101000001001000110010101010101010000101101010000100100111101001111010010110010110110110101100001101000001101000110010101010101010000101101010000100100111101001111010010110010110100110010101100001001010110000011010001100101010101010100001011010100001001001111010011110100101100101101001101011011000010110011100000111000001001010010010101010100111111001110100000001111101100000100001011100001110110010000111110110000010000100000001101111100000011111011000001111110100011111011001011100110100110010011111111100000101001001010101110101111111000001010010010101011101010000000100000001000000010000000100000001000000010000000100000001000001110000111000010010100111100001101101111000010001101101010000111000101100001100110010001110100110110000000100001010000100101001110010000111111010000100011011010000000101001010011001110110111000000101101100000000000100101001111000011011011110001100100000100010011000110000001";
			//"1011000011010000101001001101000110001100110100011000111011010001100001111101000010110101110100011000000011010001100000011101000010111101110100011000101111010000101110010010000011010000101110101101000010111110110100001011110111010001100000101101000110000000110100001011000011010000101110101101000110000010001000000101001001010101010011110100111000101101001101000010111000110001001101111011100010000000";
			//"1101000010100100110100011000110011010001100011101101000110000111110100001011010111010001100000001101000110000001110100001011110111010001100010111101000010111001001000001101000010111010110100001011111011010000101111011101000110000010110100011000000011010000101100001101000010111010110100011000001000100000010100100101010101001111010011100010110100110100001011100011000100110111";
	int32_t pOffset=21*8;//as the symbol ends at 22 bytes
	printf("Offset prev=== %d\n",pOffset);
	splitByteStreamFor8ByteAndReturnUnicode(source,&pOffset,finalnew_str);
	   //extractUnicode(source,finalnew_str);
	printf("Offset Now== %d\n",pOffset);
    printf("Final Unicode New=== %s\n ,length %d \n",finalnew_str,strlen(finalnew_str));

    return 0;
}
